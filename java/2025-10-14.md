<details>
<summary>실습 코드 보기</summary>

```java
import java.awt.*; //배치관리자 정의
import java.awt.event.*; //리스너 인터페이스 정의
import javax.swing.*; //클래스, 인터페이스 포함, 하위 패키지는 포함하지 않음

public class EventTest3 extends JFrame{
	//멤버변수
	JButton btn1,btn2,btn3;
	
	//생성자
	EventTest3(){
		setTitle("독립 클래스로 이벤트 리스너 만들기");
		setLayout(new FlowLayout());
		//컴포넌트 생성
		btn1=new JButton("확인");
		btn2=new JButton("취소");
		//btn3=new JButton("배경색");
		
		//컴포넌트 부착
		add(btn1);
		add(btn2);
		//add(btn3);
		
		//2. 리스너 등록
		//확인버튼이 눌러지면 윈도우 제목 변경하기
		btn1.addActionListener(new ActionListener(){
			@Override
			public void actionPerformed(ActionEvent e) {
				// 실행할 코드
				if(btn1.getText().equals("확인"))
					btn1.setText("OK");
				else
					btn1.setText("확인");
			}
		});
		btn2.addActionListener(new ActionListener() {

			@Override
			public void actionPerformed(ActionEvent e) {
				// 실행할 코드
				if(btn2.getText().equals("취소"))
					btn2.setText("Cancel");
				else
					btn2.setText("취소");
			}	
		});
		
		//btn1.addActionListener(new My1());
		//btn2.addActionListener(new My2());

		
		setSize(300,300);
		setVisible(true);
	}
	
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		new EventTest3();
	}

}
package sec03;

import java.awt.*; //배치관리자 정의
import java.awt.event.*; //리스너 인터페이스 정의
import javax.swing.*; //클래스, 인터페이스 포함, 하위 패키지는 포함하지 않음

public class EventTest3 extends JFrame{
	//멤버변수
	JButton btn1,btn2,btn3;
	
	//생성자
	EventTest3(){
		setTitle("독립 클래스로 이벤트 리스너 만들기");
		setLayout(new FlowLayout());
		//컴포넌트 생성
		btn1=new JButton("확인");
		btn2=new JButton("취소");
		//btn3=new JButton("배경색");
		
		//컴포넌트 부착
		add(btn1);
		add(btn2);
		//add(btn3);
		
		//2. 리스너 등록
		//확인버튼이 눌러지면 윈도우 제목 변경하기
		btn1.addActionListener(new ActionListener(){
			@Override
			public void actionPerformed(ActionEvent e) {
				// 실행할 코드
				if(btn1.getText().equals("확인"))
					btn1.setText("OK");
				else
					btn1.setText("확인");
			}
		});
		btn2.addActionListener(new ActionListener() {

			@Override
			public void actionPerformed(ActionEvent e) {
				// 실행할 코드
				if(btn2.getText().equals("취소"))
					btn2.setText("Cancel");
				else
					btn2.setText("취소");
			}	
		});
		
		//btn1.addActionListener(new My1());
		//btn2.addActionListener(new My2());

		
		setSize(300,300);
		setVisible(true);
	}
	
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		new EventTest3();
	}

}

```
# 자바의 이벤트 처리

> **핵심 주제:** 이벤트 기반 프로그래밍, 리스너 구현 방법, 어댑터 클래스

---

## 1. 이벤트 처리 개요

### 이벤트 기반 프로그래밍이란?
* 프로그램의 흐름이 **이벤트(Event) 발생**에 따라 결정되는 방식입니다.
* 개발자가 모든 순서를 미리 정하는 것이 아니라, 사용자의 행동(클릭, 키 입력 등)에 따라 코드가 실행됩니다.
* 자바의 GUI 프로그램은 대부분 이 방식을 따릅니다.

### 이벤트의 종류
* **사용자 입력:** 마우스 클릭, 드래그, 키보드 입력 등
* **기타:** 센서 감지, 데이터 수신, 다른 프로그램의 메시지 등

---

## 2. 이벤트 리스너 (Event Listener)

### 기본 개념
이벤트를 처리하기 위해서는 3가지 요소가 필요합니다.
1.  **이벤트 소스:** 이벤트를 발생시킨 부품 (예: 버튼)
2.  **이벤트 객체:** 발생한 이벤트의 상세 정보(위치, 종류 등)를 담은 것
3.  **이벤트 리스너:** 이벤트를 실제로 처리하는 담당자 (개발자가 작성하는 코드)

### 주요 리스너 종류
자바에서는 이벤트 종류에 따라 각기 다른 **인터페이스**를 제공합니다.

* **ActionListener:** 버튼 클릭, 메뉴 선택, 엔터키 입력 시 사용
* **ItemListener:** 체크박스나 라디오버튼의 선택 상태가 바뀔 때 사용
* **KeyListener:** 키보드를 누르거나 뗄 때 사용
* **MouseListener:** 마우스 클릭, 드래그, 커서 진입/이탈 시 사용

---

## 3. 리스너를 만드는 3가지 방법

이벤트 리스너를 코드에 어디에 작성하느냐에 따라 3가지 형태로 나뉩니다.

### 1) 내부 클래스 (Inner Class) 방식 ★ (가장 많이 사용)
* **특징:** 클래스 안에 또 다른 클래스(리스너)를 작성하는 방식입니다.
* **장점:** 윈도우 창(Frame)에 있는 버튼이나 텍스트 상자 등을 내 것처럼 편하게 가져다 쓸 수 있어 가장 선호됩니다.

### 2) 익명 클래스 (Anonymous Class) 방식
* **특징:** 클래스에 굳이 이름을 붙이지 않고, 그 자리에서 즉석으로 만드는 방식입니다.
* **장점:** 코드가 짧고 간단해서, 기능이 단순한 리스너를 만들 때 유용합니다.

### 3) 독립 클래스 (Independent Class) 방식
* **특징:** 리스너를 아예 별도의 파일로 따로 만드는 방식입니다.
* **장점:** 여러 곳에서 똑같은 기능이 필요할 때 재사용하기 좋습니다.
* **단점:** 다른 파일에 있는 윈도우 창의 부품을 가져다 쓰기가 번거롭습니다.

---

## 4. 어댑터 클래스 (Adapter Class)

### 왜 사용하는가?
* `MouseListener` 같은 경우, 클릭 하나만 처리하고 싶어도 인터페이스의 규칙 때문에 5개의 기능을 모두 만들어야 하는 번거로움이 있습니다.
* 이때 **어댑터 클래스**를 사용하면, 미리 껍데기가 만들어져 있어서 **내가 필요한 기능 딱 하나만 골라서** 만들면 됩니다.
* *(참고: 기능이 하나뿐인 `ActionListener` 등은 어댑터 클래스가 따로 없습니다.)*

---

## 5. 핵심 요약
1.  GUI 프로그래밍은 **이벤트**가 발생하면 **리스너**가 실행되는 구조다.
2.  리스너는 주로 **내부 클래스**나 **익명 클래스**로 만든다. (변수 접근이 쉬워서)
3.  구현해야 할 기능이 많을 때는 **어댑터 클래스**를 상속받아 필요한 것만 쓴다.