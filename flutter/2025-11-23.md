# 2025-11-23 플러터 복습

## 캡슐화가 안된 경우
class BankAccount {
  double balance = 0; // 누구나 접근 가능

  void deposit(double amount) {
    balance += amount;
  }

  void withdraw(double amount) {
    balance -= amount;
  }
}

void main() {
  var account = BankAccount();
  account.balance = -1000; // 외부에서 직접 수정 가능 (문제 발생!)
  print(account.balance);  // -1000 출력
}

## 캡슐화된 경우
class BankAccount {
  double _balance = 0; // private 필드

  double get balance => _balance; // 읽기 전용 getter

  void deposit(double amount) {
    if (amount > 0) {
      _balance += amount;
    }
  }

  void withdraw(double amount) {
    if (amount > 0 && amount <= _balance) {
      _balance -= amount;
    }
  }
}

void main() {
  var account = BankAccount();
  account.deposit(500);
  account.withdraw(200);
  print(account.balance); // 300 출력

  // account._balance = -1000; // ❌ 외부에서 접근 불가
}

==============================

class BankAccount {
  final String accountNumber; // 계좌번호는 불변
  double _balance = 0;

  BankAccount(this.accountNumber);

  double get balance => _balance; // 읽기 전용 getter

  void deposit(double amount) {
    if (amount > 0) _balance += amount;
  }

  void withdraw(double amount) {
    if (amount > 0 && amount <= _balance) _balance -= amount;
  }
}

void main() {
  var account = BankAccount("123-456");
  account.deposit(500);
  print(account.balance);       // 500 출력
  print(account.accountNumber); // "123-456" 출력
}

============================================
## 상속
//부모 클래스
class Animal {
  void eat() {
    print("동물이 먹고 있어요.");
  }
}
//자식 클래스
class Dog extends Animal {
  void bark() {
    print("멍멍!");
  }
}
//또다른 자식 클래스
class Cat extends Animal {
  void meow() {
    print("야옹~");
  }
}
void main() {
  var dog = Dog();
  dog.eat();   // 부모 클래스 메서드 사용
  dog.bark();  // 자식 클래스 고유 메서드 사용

  var cat = Cat();
  cat.eat();   // 부모 클래스 메서드 사용
  cat.meow();  // 자식 클래스 고유 메서드 사용
}

======================================
## 다형성

//부모 클래스
class Animal {
  String _name = "";
  String get name => _name;

  Animal(this._name);

  void makeSound() {
    print("$name이 소리를 내고 있어요!");
  }
}

//자식 클래스
class Dog extends Animal {
  Dog(String name) : super(name);

  @override
  void makeSound() {
    print("$name: 월월!");
  }
}

class Cat extends Animal {
  Cat(String name) : super(name);

  @override
  void makeSound() {
    print("$name: 야옹!");
  }
}

void main() {
  Dog dog = Dog("바둑이");
  Cat cat = Cat("냥이");

  //dog.makeSound();
  //cat.makeSound();

  List<Animal> animals = [dog, cat];
  for (var animal in animals) {
    animal.makeSound();
  }
}

===========================
## 추상화

// 추상 클래스 (부모)
abstract class Animal {
  String _name = "";
  String get name => _name;

  Animal(this._name);

  // 추상 메서드: 자식 클래스가 반드시 구현해야 함
  void makeSound();
}

// 자식 클래스
class Dog extends Animal {
  Dog(String name) : super(name);

  @override
  void makeSound() {
    print("$name: 월월!");
  }
}

class Cat extends Animal {
  Cat(String name) : super(name);

  @override
  void makeSound() {
    print("$name: 야옹!");
  }
}

void main() {
  Dog dog = Dog("바둑이");
  Cat cat = Cat("냥이");

  // 다형성 활용: Animal 타입으로 관리
  List<Animal> animals = [dog, cat];
  for (var animal in animals) {
    animal.makeSound(); // 각 클래스의 구현에 따라 다르게 동작
  }
}

===============================
## 인터페이스

// 인터페이스 역할을 하는 추상 클래스
abstract class Animal {
  void makeSound(); // 추상 메서드
}

// Dog 클래스는 Animal 인터페이스를 구현
class Dog implements Animal {
  @override
  void makeSound() {
    print("멍멍!");
  }
}

// Cat 클래스도 Animal 인터페이스를 구현
class Cat implements Animal {
  @override
  void makeSound() {
    print("야옹~");
  }
}

void main() {
  List<Animal> animals = [Dog(), Cat()];

  for (var animal in animals) {
    animal.makeSound(); // 공통된 인터페이스 덕분에 동일하게 호출 가능
  }
}

## 인터페이스의 장점
1. 일관성 제공
- 서로 다른 클래스라도 같은 메서드를 반드시 구현해야 하므로, 사용자는 동일한 방식으로 접근 가능.
예: makeSound()라는 메서드가 항상 존재한다는 보장.

2. 다형성 지원
- 부모 타입(인터페이스)으로 여러 자식 객체를 한 번에 다룰 수 있음.
- 위 예시처럼 List<Animal>에 Dog, Cat을 함께 넣고 동일하게 처리 가능.

3. 유연한 설계
- 상속은 "하나의 부모 클래스"만 가질 수 있지만, 인터페이스는 여러 개를 동시에 구현할 수 있음.
- 즉, 다양한 역할을 조합해서 클래스에 부여할 수 있음.

4. 확장성과 유지보수성
- 새로운 클래스가 추가되더라도 인터페이스만 맞추면 기존 코드와 쉽게 호환됨.
- 예: Bird 클래스를 추가해도 makeSound()만 구현하면 기존 구조에 바로 적용 가능.

=================================================
## mixin

// Mixin 정의
mixin Flyable {
  void fly() {
    print("하늘을 날고 있어요!");
  }
}

mixin Swimmable {
  void swim() {
    print("물속을 헤엄치고 있어요!");
  }
}

// 기본 클래스
class Animal {
  String name;
  Animal(this.name);

  void eat() {
    print("$name이(가) 먹고 있어요.");
  }
}

// mixin을 적용한 클래스
class Bird extends Animal with Flyable {
  Bird(String name) : super(name);
}

class Fish extends Animal with Swimmable {
  Fish(String name) : super(name);
}

// 여러 mixin을 동시에 적용 가능
class Duck extends Animal with Flyable, Swimmable {
  Duck(String name) : super(name);
}

void main() {
  var bird = Bird("참새");
  bird.eat();
  bird.fly();

  var fish = Fish("금붕어");
  fish.eat();
  fish.swim();

  var duck = Duck("오리");
  duck.eat();
  duck.fly();
  duck.swim();
}

## Mixin의 장점
1. 코드 재사용성
- 공통 기능을 mixin으로 정의해두면 여러 클래수에서 쉽게 재사용 가능.

2. 다중 기능 조합 가능
- 상속은 하나의 부모만 가질 수 있지만, mixin은 여러 개를 동시에 적용 가능.

3. 유연한 설계
- 클래스 계층 구조를 복잡하게 만들지 않고 필요한 기능만 붙일 수 있음.

4. 중복 제거
- 같은 기능을 여러 클래스에 반복해서 작성할 필요 없음.

## Mixin의 단점
1. 상태 공유 제한
- mixin은 주로 메서드 중심으로 기능을 제공하며, 복잡한 상태 관리에는 적합하지 않음.

2. 과도한 사용 시 혼란
- 여러 mixin을 동시에 붙이면 클래스의 책임이 모호해질 수 있음.

3. 상속과 차이점 혼동
- 상속은 "is-a" 관계(예: Dog is an Animal)
- mixin은 "can-do" 관계(예: Duck can Fly, can Swim)
